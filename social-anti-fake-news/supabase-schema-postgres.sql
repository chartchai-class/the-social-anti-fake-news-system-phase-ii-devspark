-- Supabase (Postgres) schema for Anti-Fake News System
-- Aligns with frontend services and uses Supabase auth + Storage

-- 1) Enum types
DO $$ BEGIN
  CREATE TYPE news_status AS ENUM ('FAKE','NOT_FAKE','UNDECIDED');
EXCEPTION WHEN duplicate_object THEN null; END $$;

DO $$ BEGIN
  CREATE TYPE vote_type AS ENUM ('FAKE','NOT_FAKE');
EXCEPTION WHEN duplicate_object THEN null; END $$;

DO $$ BEGIN
  CREATE TYPE role_type AS ENUM ('READER','MEMBER','ADMIN');
EXCEPTION WHEN duplicate_object THEN null; END $$;

-- 2) Profiles table (extends auth.users)
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid PRIMARY KEY REFERENCES auth.users (id) ON DELETE CASCADE,
  username text UNIQUE,
  email text,
  first_name text,
  last_name text,
  full_name text,
  image_url text,
  role role_type NOT NULL DEFAULT 'READER',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz
);

-- 3) News table
CREATE TABLE IF NOT EXISTS public.news (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title text NOT NULL,
  short_detail text NOT NULL,
  full_detail text NOT NULL,
  image_url text,
  status news_status NOT NULL DEFAULT 'UNDECIDED',
  reporter_id uuid NOT NULL REFERENCES public.profiles (id) ON DELETE RESTRICT,
  soft_deleted boolean NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz
);

CREATE INDEX IF NOT EXISTS idx_news_reporter ON public.news (reporter_id);

-- 4) Comments table
CREATE TABLE IF NOT EXISTS public.comments (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  news_id bigint NOT NULL REFERENCES public.news (id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES public.profiles (id) ON DELETE RESTRICT,
  text text NOT NULL,
  image_url text,
  vote_type vote_type NULL,
  soft_deleted boolean NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz
);

CREATE INDEX IF NOT EXISTS idx_comments_news ON public.comments (news_id);
CREATE INDEX IF NOT EXISTS idx_comments_user ON public.comments (user_id);

-- 5) Votes table (unique one vote per user per news)
CREATE TABLE IF NOT EXISTS public.votes (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  news_id bigint NOT NULL REFERENCES public.news (id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES public.profiles (id) ON DELETE RESTRICT,
  vote_type vote_type NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz,
  CONSTRAINT uk_vote_once UNIQUE (news_id, user_id)
);

CREATE INDEX IF NOT EXISTS idx_votes_news ON public.votes (news_id);
CREATE INDEX IF NOT EXISTS idx_votes_user ON public.votes (user_id);

-- 6) RLS policies
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.news ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.votes ENABLE ROW LEVEL SECURITY;

-- Profiles: anyone can read, users can update own
DO $$ BEGIN
  CREATE POLICY profiles_select ON public.profiles
  FOR SELECT USING (true);
EXCEPTION WHEN duplicate_object THEN null; END $$;

DO $$ BEGIN
  CREATE POLICY profiles_update_own ON public.profiles
  FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
EXCEPTION WHEN duplicate_object THEN null; END $$;

-- News: anyone can read non-deleted; authenticated can insert; reporter/admin can update own
DO $$ BEGIN
  CREATE POLICY news_select ON public.news
  FOR SELECT USING (soft_deleted = false);
EXCEPTION WHEN duplicate_object THEN null; END $$;

DO $$ BEGIN
  CREATE POLICY news_insert_auth ON public.news
  FOR INSERT TO authenticated WITH CHECK (reporter_id = auth.uid());
EXCEPTION WHEN duplicate_object THEN null; END $$;

DO $$ BEGIN
  CREATE POLICY news_update_owner ON public.news
  FOR UPDATE USING (reporter_id = auth.uid());
EXCEPTION WHEN duplicate_object THEN null; END $$;

-- Comments: anyone can read non-deleted; authenticated can insert own
DO $$ BEGIN
  CREATE POLICY comments_select ON public.comments
  FOR SELECT USING (soft_deleted = false);
EXCEPTION WHEN duplicate_object THEN null; END $$;

DO $$ BEGIN
  CREATE POLICY comments_insert_auth ON public.comments
  FOR INSERT TO authenticated WITH CHECK (user_id = auth.uid());
EXCEPTION WHEN duplicate_object THEN null; END $$;

-- Votes: anyone can read; authenticated can insert/update own
DO $$ BEGIN
  CREATE POLICY votes_select ON public.votes
  FOR SELECT USING (true);
EXCEPTION WHEN duplicate_object THEN null; END $$;

DO $$ BEGIN
  CREATE POLICY votes_insert_auth ON public.votes
  FOR INSERT TO authenticated WITH CHECK (user_id = auth.uid());
EXCEPTION WHEN duplicate_object THEN null; END $$;

DO $$ BEGIN
  CREATE POLICY votes_update_auth ON public.votes
  FOR UPDATE USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());
EXCEPTION WHEN duplicate_object THEN null; END $$;

-- 7) Trigger to maintain updated_at
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DO $$ BEGIN
  CREATE TRIGGER set_updated_at_profiles
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
EXCEPTION WHEN duplicate_object THEN null; END $$;

DO $$ BEGIN
  CREATE TRIGGER set_updated_at_news
  BEFORE UPDATE ON public.news
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
EXCEPTION WHEN duplicate_object THEN null; END $$;

DO $$ BEGIN
  CREATE TRIGGER set_updated_at_comments
  BEFORE UPDATE ON public.comments
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
EXCEPTION WHEN duplicate_object THEN null; END $$;

DO $$ BEGIN
  CREATE TRIGGER set_updated_at_votes
  BEFORE UPDATE ON public.votes
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
EXCEPTION WHEN duplicate_object THEN null; END $$;

-- 8) Optional: profile row on signup helper (use Edge Functions or client update)
-- Frontend already updates/creates profiles after sign-up, so no trigger here.


